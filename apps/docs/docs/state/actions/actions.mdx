---
sidebar_label: 'Actions'
sidebar_position: 5
title: 'Actions'
hide_title: true
---

# @rx-angular/state/actions

[![npm](https://img.shields.io/npm/v/%40rx-angular%2Fstate.svg)](https://www.npmjs.com/package/%40rx-angular%2Fstate)
![rx-angular CI](https://github.com/rx-angular/rx-angular/workflows/rx-angular%20CI/badge.svg?branch=master)

> This package provides a handy way handle have reactive events of any type.
> It fit's perfectly for situations like debounce user input or switchMap a HTTP request

## Key features

- ✅ No-Boilerplate
- ✅ Minimal memory footprint through a Proxy object and lazy initialization
- ✅ Auto unsubscribe on component or service destroy
- ✅ Trigger effects
- ✅ Configurable transformations to have lines in the template
- ✅ Fully Typed

## Install

```bash
npm install --save @rx-angular/state
# or
yarn add @rx-angular/state
```

This package helps to reduce code used to create composable action streams.
It mostly is used in combination with state management libs to handle user interaction and backend communication.

## Setup

`Actions` can be imported as following:

```ts
import { rxActions } from '@rx-angular/state/actions';

@Component({
  standalone: true,
  template: `...`,
})
export class AnyComponent {
  actions = rxActions<UI>();
}
```

## Usage in component to handle UI interaction

This example shows how to create an action instance for the components template.
We can see how to apply behaviour onto the search input (debouncing the user input for 300 ms).

```typescript
import { rxActions } from '@rx-angular/state/actions';

type ListUi = { searchInput: string };

@Component({
  template: `<input name="search" (change)="ui.searchInput($event)" />`,
})
class ListComponent {
  protected ui = rxActions<ListUi>();
  // UI input with applied behaviour
  @Output()
  queryUpdate$ = this.ui.searchInput$.pipe(debounceTime(300));
}
```

### Test usage in component to handle UI interaction

```typescript
import { ListComponent } from './list.component';

function setupComponent(cfg?: {
  transformFns?: ActionTransforms<ListUi>;
  providers?: Provider[];
}) {
  let providers = [];
  if (Array.isArray(cfg?.providers)) {
    providers = cfg.providers;
  }
  TestBed.configureTestingModule({
    declarations: [ListComponent],
  });

  const fixture = TestBed.createComponent(ListComponent);
  const component = fixture.componentInstance;

  const searchInputElem: HTMLInputElement = fixture.nativeElement.querySelector(
    'input[name="search"]'
  );
  const searchInputChange = (value: string) => {
    searchInputElem.value = value;
    searchInputElem.dispatchEvent(new Event('change'));
  };

  return { fixture, component, searchInputChange };
}

describe('actions in a component', () => {
  it('should emit event if input fires change event', async () => {
    const { component, fixture, searchInputChange } = setupComponent();
    const spyEmission = jest.fn((value: ListUi['searchInput']) => void 0);

    component.queryUpdate$.subscribe(spyEmission);
    expect(spyEmission).toBeCalledTimes(0);

    searchInputChange('abc');
    expect(spyEmission).toBeCalledTimes(0); // should debounce emission
    await wait(310);
    expect(spyEmission).toBeCalledTimes(1); // then fire
    expect(spyEmission).toBeCalledWith('abc'); // with value

    fixture.destroy(); // should unsubscribe onDestroy
    searchInputChange('xyz');
    expect(spyEmission).toBeCalledTimes(1); // and not listening anymore
  });
});
```

## Usage in a service to handle data fetching

In this example we see how to use an action instance to handle data fetching.
We can see how to apply behaviour onto the refresh calls (`exhaustMap` the HTTP requests).

```typescript
import { rxActions } from '@rx-angular/state/actions';

type Actions = { refresh: void };

@Injectable({ providedIn: 'root' })
export class MovieService {
  private movieResource = inject(MovieResource);
  private actions = rxActions<Actions>();
  // data refresh with applied behaviour
  movies$ = this.actions.refresh$.pipe(
    exhaustMap((_) => this.movieResource.getMovies())
  );

  refresh() {
    this.actions.refresh();
  }
}
```

### Testing usage in a service to handle data fetching

To test actions in a service most of the time mock logic is required.

```typescript
import { MovieResource } from './movie.resource';
import { MovieService } from './movie.service';

// Test helper code ==========

export class MovieResourceMock {
  httpRequest = new Subject<Movie[]>();
  getMovies(qurey?: string): Observable<Movie[]> {
    return this.httpRequest.pipe(take(1));
  }
}

function setupService() {
  TestBed.overrideProvider(MovieResource, {
    useFactory: () => new MovieResourceMock(),
  });

  const service = TestBed.inject(MovieService);
  const resource = TestBed.inject(MovieResource) as MovieResourceMock;
  return { service, resource };
}

// Test code ==========

describe('actions in a service', () => {
  it('should emit event if method is called', async () => {
    const { service, resource } = setupService();
    const spyEmission = jest.fn((value: Movie[]) => void 0);

    service.movies$.subscribe(spyEmission);
    service.refresh();
    service.refresh(); // multiple triggers
    expect(spyEmission).toBeCalledTimes(0); // don't fire new http requests while old one is running
    resource.httpRequest.next([{ title: 'test' }]); // simulate response
    expect(spyEmission).toBeCalledTimes(1); // response arrived 1 time
    expect(spyEmission).toBeCalledWith([{ title: 'test' }]); // with simulated result
  });
});
```

## Handling side effects on event emission

In this example we use the `on` shorthand to trigger a side effect every time the event it emitted.
It returns a function which when called stops firing the side effect.

```typescript
import { rxActions } from '@rx-angular/state/actions';

type ListUi = { refresh: string };

@Component({
  template: `<button (click)="editUi.refresh($event)">Refresh</button>`,
})
class ListComponent {
  protected ui = rxActions<ListUiEf>();
  protected movieResource = inject(MovieResource);
  protected toastService = inject(ToastService);

  private saveObsEf = this.ui.onRefresh(
    (save$) => save$.pipe(exhaustMap((_) => this.movieResource.getMovies())), // apply behaviour
    () => this.toastService.showSuccess('Refresh done!') // fire side effect
  );
}
```

### Test handling side effects on event emission

```typescript
// Test helper code ==========

function getEfComponentAndService(cfg?: {
  transformFns?: ActionTransforms<ListUi>;
}) {
  TestBed.configureTestingModule({ declarations: [ListEfComponent] });
  TestBed.overrideProvider(MovieResource, {
    useFactory: () => new MovieResourceMock(),
  });

  const resource = TestBed.inject(MovieResource) as MovieResourceMock;
  const toast = TestBed.inject(ToastService);

  const fixture = TestBed.createComponent(ListEfComponent);
  const component = fixture.componentInstance;

  const refreshButtonElem: HTMLInputElement =
    fixture.nativeElement.querySelector('button');
  const refreshClick = () => {
    refreshButtonElem.dispatchEvent(new Event('click'));
  };

  return { fixture, component, refreshClick, resource, toast };
}

// Test code ==========

describe('action effect in a Component', () => {
  it('should emit event if method is called', async () => {
    const { refreshClick, resource, toast } = getEfComponentAndService();
    const spyToast = jest.spyOn(toast, 'showSuccess');

    refreshClick();
    refreshClick(); // multiple triggers
    expect(spyToast).toBeCalledTimes(0); // don't fire new http requests while old one is running
    resource.httpResponse.next([{ title: 'test' }]);
    expect(spyToast).toBeCalledTimes(1); // response arrived 1 time
    expect(spyToast).toBeCalledWith('Refresh done!'); // with simulated result
  });
});
```

## Unsubscribing from events programmatically

```typescript
import { rxActions } from '@rx-angular/state/actions';

@Component(...)
class ListComponent {
  protected ui = rxActions<ListUi>();
   private saveObsEf = this.ui.onSave(
      (save$) => save$.pipe(exhaustMap(_ => this.movieService.refresh(q)), // apply behaviour
      (list: Movie[]) => this.toastService.showSuccess(list) // fire side effect
    );

  stopListenToClick() {
    this.saveObsEf();
  }
}
```

### Test unsubscribing from events programmatically

```typescript
// Test code ==========

describe('action effect in a Component', () => {
  it('should emit event if method is called', async () => {
    const { refreshClick, resource, toast } = getEfComponentAndService();
    const spyToast = jest.spyOn(toast, 'showSuccess');

    refreshClick();
    refreshClick(); // multiple triggers
    expect(spyToast).toBeCalledTimes(0); // don't fire new http requests while old one is running
    resource.httpResponse.next([{ title: 'test' }]);
    expect(spyToast).toBeCalledTimes(1); // response arrived 1 time
    expect(spyToast).toBeCalledWith('Refresh done!'); // with simulated result
  });
});
```

## Transform events in a central place

```typescript
export class MovieServiceMock {
  httpRequest = new Subject<Movie[]>();
  getMovies(qurey?: string): Observable<Movie[]> {
    return this.httpRequest.pipe(take(1));
  }
}

function setupService() {
  TestBed.overrideProvider(MovieResource, {
    useFactory: () => new MovieResourceMock(),
  });

  const service = TestBed.inject(MovieService);
  const resource = TestBed.inject(MovieResource) as MovieResourceMock;
  return { service, resource };
}
```

Often we process `Events` from the template and occasionally also trigger those channels in the class programmatically.

This leads to a cluttered codebase as we have to consider first the value in the event which leads to un necessary and repetitive code in the template.
This is also true for the programmatic usage in the component class or a service.

To ease this pain we can manage this login with `transforms`.

You can write your own transforms, leverage Browser APIs like `String` and `Boolean` or use the predefined functions.

### Use existing transform functions

The existing transform functions are:

- `preventDefault` - calls `preventDefault` on a passed event
- `stopPropagation`
- `preventDefaultStopPropagation`
- `eventValue`

Here we see how to use an action transforms. This concept is similar to Input transforms.
The logic is placed in a single place and transforms the event before emission.

```typescript
import { rxActions, eventValue } from '@rx-angular/state/actions';

type ListUi = { searchInput: string };

@Component({
  // takes a DOM Event
  template: `<input name="search" (change)="ui.searchInput($event)" />`,
})
class ListComponent {
  protected ui = rxActions<ListUi>(({ transforms }) =>
    transforms({ searchInput: eventValue })
  );

  searchChange(query: string) {
    // takes a string
    this.ui.searchInput(query);
  }
}
```

### Use custom transform functions

```typescript
import { rxActions, eventValue } from '@rx-angular/state/actions';

type ListUi = { searchInput: string };

const codeTransform = (v) => parseInt(eventValue(v)) + '#POSTFIX';

@Component({
  // takes a DOM Event
  template: `<input
    type="number"
    name="code"
    (change)="ui.codeChange($event)"
  />`,
})
class ListComponent {
  protected ui = rxActions<ListUi>(({ transform }) =>
    transform({
      codeChange: codeTransform,
    })
  );

  searchChange(code: number) {
    // takes a number
    this.ui.codeChange(query);
  }
}
```

### Test transform functions

```typescript
// Test helper code ==========

function getTransformComponentAndService() {
  TestBed.configureTestingModule({ declarations: [ListTransformComponent] });
  const fixture = TestBed.createComponent(ListTransformComponent);
  const component = fixture.componentInstance;

  const searchInputElem: HTMLInputElement = fixture.nativeElement.querySelector(
    'input[name="search"]'
  );
  const searchInputChange = (value: string) => {
    searchInputElem.value = value;
    searchInputElem.dispatchEvent(new Event('change'));
  };

  return { component, searchInputChange };
}

// Test code ==========

describe('action transform in a component', () => {
  it('should emit event if method is called', async () => {
    const { searchInputChange, component } = getTransformComponentAndService();
    const spyEmission = jest.fn(() => void 0);

    component.queryUpdate.subscribe(spyEmission);
    searchInputChange('1.5');
    expect(spyEmission).toBeCalledTimes(1);
    expect(spyEmission).toBeCalledWith('1#POSTFIX');
    component.searchChange('2.5');
    expect(spyEmission).toBeCalledTimes(2);
    expect(spyEmission).toBeCalledWith('2#POSTFIX');
  });
});
```
