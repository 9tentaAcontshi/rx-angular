---
sidebar_label: 'Actions'
sidebar_position: 5
title: 'Actions'
hide_title: true
---

# @rx-angular/state/actions

[![npm](https://img.shields.io/npm/v/%40rx-angular%2Fstate.svg)](https://www.npmjs.com/package/%40rx-angular%2Fstate)
![rx-angular CI](https://github.com/rx-angular/rx-angular/workflows/rx-angular%20CI/badge.svg?branch=master)

> This package provides a handy way handle have reactive events of any type.
> It fit's perfectly for situations like debounce user input or switchMap a HTTP request

## Key features

- ✅ No-Boilerplate
- ✅ Minimal memory footprint through a Proxy object and lazy initialization
- ✅ Auto unsubscribe on component or service destroy
- ✅ Trigger effects
- ✅ Configurable transformations to have lines in the template
- ✅ Fully Typed

## Install

```bash
npm install --save @rx-angular/state
# or
yarn add @rx-angular/state
```

This package helps to reduce code used to create composable action streams.
It mostly is used in combination with state management libs to handle user interaction and backend communication.

## Setup

`Actions` can be imported as following:

```ts
import { rxActions } from '@rx-angular/state/actions';

@Component({
  standalone: true,
  template: `...`,
})
export class AnyComponent {
  actions = rxActions<UI>();
}
```

### Basic usage in a Component

# Actions

Primitive building block to handle event logic and event creation.
It is imported via `import { rxActions } from '@rx-angular/state/actions';`

The action automatically creates an Observable and a callback function for imperative programming based on the types. It also has a new shorthand to tie the event changes to a side effect.

```typescript
import { rxActions } from '@rx-angular/state/actions';

@Component({...})
export class AnyComponent {
  ui = rxActions<{ name: string }>();
  name$ = this.ui.name$; // Observable<string> - listens to name changes
  emitName = this.ui.name; // (name: string) => void - emits name change
  sub = this.ui.onName(console.log) // () => void - when called stops the side effect execution
}
```

## Usage in component to handle UI interaction

This example shows how to create an action instance for the components template.
We can see how to apply behaviour onto the search input (debouncing the user input for 300 ms).

```typescript
import { rxActions } from '@rx-angular/state/actions';

type ListUi = { searchInput: string };

@Component({
  template: ` <input name="search" (change)="ui.searchInput($event)" /> `,
})
class ListComponent {
  protected ui = rxActions<ListUi>();
  // UI input with applied behaviour
  query$ = this.ui.searchInput$.pipe(debounceTime(300));
}
```

## Usage in a service to handle data fetching

In this example we see how to use an action instance to handle data fetching.
We can see how to apply behaviour onto the refresh calls (`exhaustMap` the HTTP requests).

```typescript
import { rxActions } from '@rx-angular/state/actions';

type Actions = { refresh: void };

@Injectable({ providedIn: 'root' })
export class MovieService {
  private actions = rxActions<Actions>();
  // data refresh with applied behaviour
  movies$ = this.actions.refresh$.pipe(exhaustMap((_) => getMovies()));

  refresh() {
    this.actions.refresh();
  }
}
```

## Handling side effects on event emission

In this example we use the `on` shorthand to trigger a side effect every time the event it emitted.
It returns a function which when called stops firing the side effect.

```typescript
import { rxActions } from '@rx-angular/state/actions';

type EditUi = { save: void };

@Component({
  template: ` <button (click)="editUi.save($event)" /> `,
})
class ListComponent {
  protected editUi = rxActions<EditUi>();
  private saveObsEf = this.editUi.onSearchInput(
    (searchInput$) => searchInput$.pipe(debounceTime(300)), // apply behaviour
    (q: string) => this.state.search(q) // fire side effect
  );

  // It is also possible to use tap, however this is not recommended to do
  private saveObsEf2 = this.editUi.onSearchInput((query$) =>
    query$.pipe(
      debounceTime(300), // apply behaviour
      tap((q: string) => this.state.search(q)) // fire side effect
    )
  );
}
```

### Unsubscribe from events programmatically

```typescript
import { rxActions } from '@rx-angular/state/actions';

type EditUi = { save: void };

@Component({
  template: ` <button (click)="editUi.save($event)" /> `,
})
class ListComponent {
  protected editUi = rxActions<EditUi>();
  private saveObsEf = this.editUi.onSearchInput(
    (searchInput$) => searchInput$.pipe(debounceTime(300)), // apply behaviour
    (q: string) => this.state.search(q) // fire side effect
  );

  stopListenToClick() {
    this.saveObsEf();
  }
}
```

## Transform events in a central place

Often we process `Events` from the template and occasionally also trigger those channels in the class programmatically.

This leads to a cluttered codebase as we have to consider first the value in the event which leads to un necessary and repetitive code in the template.
This is also true for the programmatic usage in the component class or a service.

To ease this pain we can manage this login with `transforms`.

You can write your own transforms, leverage Browser APIs like `String` and `Boolean` or use the predefined functions.

### Use existing transform functions

The existing transform functions are:

- `preventDefault` - calls `preventDefault` on a passed event
- `stopPropagation`
- `preventDefaultStopPropagation`
- `eventValue`

Here we see how to use an action transforms. This concept is similar to Input transforms.
The logic is placed in a single place and transforms the event before emission.

```typescript
import { rxActions, eventValue } from '@rx-angular/state/actions';

type ListUi = { searchInput: string };

@Component({
  // takes a DOM Event
  template: `<input name="search" (change)="ui.searchInput($event)" />`,
})
class ListComponent {
  protected ui = rxActions<ListUi>(({ transform }) =>
    transform({ searchInput: eventValue })
  );

  searchChange(query: string) {
    // takes a string
    this.ui.searchInput(query);
  }
}
```

## Use custom transform functions

```typescript
import { rxActions, eventValue } from '@rx-angular/state/actions';

type ListUi = { searchInput: string };

@Component({
  // takes a DOM Event
  template: `<input
    type="number"
    name="code"
    (change)="ui.codeChange($event)"
  />`,
})
class ListComponent {
  protected ui = rxActions<ListUi>(({ transform }) =>
    transform({
      codeChange: (v) => Number(eventValue(v)) + '#POSTFIX',
    })
  );

  searchChange(code: number) {
    // takes a number
    this.ui.codeChange(query);
  }
}
```
