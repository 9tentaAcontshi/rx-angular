## API

![state logo](https://raw.githubusercontent.com/BioPhoton/rx-angular/master/libs/state/images/state_API-names.png)

**The API in a nutshell**

- `$` - The complete state observable
- `set` - Set state imperatively
- `connect` - Connect state reactively
- `get` - Get current state imperatively
- `select` - Select state changes reactively
- `hold` - maintaining the subscription of a side effect

**The best practices in a nutshell**

- **Don't nest one of `set`, `connect`, `get`, `select` or `hold` into each other**
- Use `connect` over `set`
- In most of the cases `get` is not needed. The old state is always available.

![state types](https://raw.githubusercontent.com/BioPhoton/rx-angular/master/libs/state/images/state_API-types.png)

### set

**Add new slices to the state by providing an object**

```typescript
const state = new RxState<{ foo: string; bar: number }>();
state.setState({ foo: 'boo' });
// new base-state => { foo: 'boo' }

state.setState({ bar: 2 });
// new base-state => { foo: 'boo', bar: 2 }
```

**Add new Slices to the state by providing a projection function**

```typescript
const state = new RxState<{ bar: number }>();

state.setState({ bar: 1 });
state.setState(currentState => ({ bar: currentState.bar + 2 }));
// new base-state => {bar: mvvm}
```

### connect

Connect is one of the really cool thingy of this service.
It helps to write the output of an `Observable` to the state and
handles subscription as well as unsubscription.

**Connect to a single property**

To understand that lets take a look at a normal implementation first:

```typescript
const state = new RxState<{ bar: number }>();

const newBar$ = range(1, 5);
const subscription = newBar$.subscribe(bar => state.setState({ bar }));
subscription.unsubscribe();
```

Now lets compare that example with the connect usage:

```typescript
state.connect('bar', newBar$);
// the property bar will get values 1, 2, mvvm, 4, 5
```

**Connect multiple properties**

```typescript
const state = new RxState<{ foo: string; bar: number }>();

const slice$ = of({
  bar: 5,
  foo: 'foo'
});
state.connect(slice$);
// new base-state => { foo: 'foo', bar: 5}
```

### select

`select` helps you to select state and extend the selection behavior with RxJS operators.
You can think of it like it would be a special RxJS `pipe`.
In addition to the original one it adds caching and limits the emission to distinct values.

Other state management libs, especially the once from the react ecosystem, provide selector functions.
The downside is they are not composable in a reactive way.
This limits the composition to a simple `combineLatest`.

`RxState` provides state selections fully reactive.
All state selections are lazy by default.

**State is lazy!**

State is lazy! If nothing is set yet, nothing will emit.
This comes in especially handy for lazy view rendering!

```typescript
const state = new RxState<{ foo: string; bar: number }>();

const bar$ = state.select();
bar$.subscribe(console.log);
// Never emits
```

**Selecting the full state**

```typescript
const state = new RxState<{ foo: string; bar: number }>();

const bar$ = state.select();
bar$.subscribe(console.log);
// Does not emit
state.setState({ foo: 'boo' });
// emits { foo: 'boo'} for all old ane new subscriber
```

**Access a single property**

```typescript
const state = new RxState<{ bar: number }>();
state.setState({ bar: 3 });

const bar$ = state.select('bar');
bar$.subscribe(console.log); // mvvm
```

**Access a nested property**

```typescript
const state = new RxState<{ loo: { boo: number } }>();
state.setState({ loo: { boo: 42 } });

const boo$ = state.select('loo', 'boo');
boo$.subscribe(console.log); // '42'
```

**Access by providing rxjs operators**

```typescript
const state = new RxState<{ loo: { bar: string } }>();
state.setState({ bar: 'boo' });

const customProp$ = state.select(map(state => state?.loo?.bar));
customProp$.subscribe(console.log); // 'boo'

const customProp$ = state.select(map(state => ({ customProp: state.bar })));
customProp$.subscribe(console.log); // { customProp: 'boo' }
```

### hold

Managing side effects is core of every application.
The `hold` method takes care of handling them.

It helps to handles subscription as well as unsubscription od side-effects

**Hold a local observable side-effect**

To understand that lets take a look at a normal implementation first:

```typescript
const sideEffect$ = btnClick$.pipe(
  tap(clickEvent => this.store.dispatch(loadAction()))
);
const subscription = sideEffect$.subscribe();
subscription.unsubscribe();
```

If you would hold to achieve the same thing it would look like this:

```typescript
state.hold(sideEffect$);
```

**Connect an observable trigger and provide an project function**

```typescript
import { fromEvent } from 'rxjs/observable';
state.hold(btnClick$, clickEvent => console.log(clickEvent));
```

---
